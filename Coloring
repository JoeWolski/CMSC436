import java.util.Arrays;
public class Coloring {
    //Assuming topleft is (0,0)

    final int height = 480; //y
    final int width = 640; //x

    //2D array for temperature (row , column) (y,x)
    //0.0 by default... 0.0 = transparent/not applied to bitmap (default value might have to change)
    //Look at Arrays.fill()
    float[][] temperatures = new float[height-1][width-1];

    //2D array for holding points
    //0 = no point there, 1 = point there
    int[][] points = new int[height-1][width-1];


    public void run() {

        while (true){      //replace with (user did not press finish button)

            float takenTemp = 0.0f; //whatever was taken (replace with parameter)
            int takenX = 0; //replace with x coordinate (replace with point.x parameter cast to int)
            int takenY = 0; //replace with y coordinate (replace with point.y parameter cast to int)

            temperatures[takenY][takenX] = takenTemp;
            points[takenY][takenX] = 1;
            int pointsInRange = rangedPoints(takenY, takenX);

            int range = 50 - (2 * (pointsInRange - 1));

            //Cell averaging all the points within range of initial point
            for (int i = 1; i <= range; i++) {
                //check if in bound
                boolean lowerX = true;
                boolean upperX = true;
                if(takenX - i < 0){ lowerX = false;}
                if(takenX + i >= width){ upperX = false;}

                boolean lowerY = true;
                boolean upperY = true;
                if(takenY - i <0){ lowerY =false;}
                if(takenY + i >= height){upperY = false;}

                for(int j = 0; j <= i; i++){
                    boolean upper = true; //for y+j is in boundary
                    boolean lower = true;
                    if(takenY - j <0){ upper =false;}
                    if(takenY + j >= height){lower = false;}

                    if(upperX){
                        if(upper){
                            cellAverage(takenY+j,takenX+i);
                        }
                        if(lower){
                            cellAverage(takenY-j,takenX+i);
                        }
                    }
                    if(lowerX){
                        if(upper){
                            cellAverage(takenY+j,takenX-i);
                        }
                        if(lower){
                            cellAverage(takenY-j,takenX-i);
                        }
                    }
                }

                for(int k = 0; k <= i-1; i++){ //do not need to check corner again
                    boolean upper = true; //for y+j is in boundary
                    boolean lower = true;
                    if(takenX - k <0){ upper =false;}
                    if(takenX + k >= width){lower = false;}

                    if(upperY){
                        if(upper){
                            cellAverage(takenY+i,takenX+k);
                        }
                        if(lower){
                            cellAverage(takenY+i,takenX-k);
                        }
                    }
                    if(lowerY){
                        if(upper){
                            cellAverage(takenY-i,takenX+k);
                        }
                        if(lower){
                            cellAverage(takenY-i,takenX-k);
                        }
                    }
                }
            }


        }
    }

    //Computes the average based on temperature around it
    private void cellAverage(int y, int x){
        int count = 0;
        float total = 0.0f;
        boolean lowerX = true;
        boolean upperX = true;
        if(x - 1 < 0){ lowerX = false;}
        if(x + 1 >= width){ upperX = false;}

        boolean lowerY = true;
        boolean upperY = true;
        if(y - 1 <0){ lowerY =false;}
        if(y + 1 >= height){upperY = false;}


        //All these if statements are checking the 8 pixel around..so 8 if statements
        if(lowerX){
           if(temperatures[y][x-1] != 0){
               total += temperatures[y][x-1];
               count++;
           }
            if(lowerY){
                if(temperatures[y-1][x-1] != 0){
                    total += temperatures[y-1][x-1];
                    count++;
                }
            }

            if(upperY){
                if(temperatures[y+1][x-1] != 0){
                    total += temperatures[y+1][x-1];
                    count++;
                }
            }
        }

        if(upperX){
            if(temperatures[y][x+1] != 0){
                total += temperatures[y][x+1];
                count++;
            }
            if(lowerY){
                if(temperatures[y-1][x+1] != 0){
                    total += temperatures[y-1][x+1];
                    count++;
                }
            }

            if(upperY){
                if(temperatures[y+1][x+1] != 0){
                    total += temperatures[y+1][x+1];
                    count++;
                }
            }
        }

        if(lowerY){
            if(temperatures[y-1][x] != 0){
                total += temperatures[y-1][x];
                count++;
            }
        }

        if(upperY){
            if(temperatures[y+1][x] != 0){
                total += temperatures[y+1][x];
                count++;
            }
        }

        if(count > 0){
                temperatures[y][x] = total/((float)count);
        }
    }

    //Returns the number of points within 25 pixels of (x,y)
    //Note: to make this simpler for now, it is a square area rather circle
    //Might change this in future....
    private int rangedPoints(int y, int x) {
        int count = 0;
        int rangeY;
        int rangeX;
        int startX;
        int startY;

        //checking if it hits any boundary
        if (y - 25 < 0) { //hits upper
            rangeY = y + 25;
            startY = 0;
        } else if (y + 25 >= height) { //hits lower
            rangeY = height - 1 - y + 25;
            startY = y - 25;
        } else {
            rangeY = 50;
            startY = y - 25;
        }

        if (x - 25 < 0) { //hits left
            rangeX = x + 25;
            startX = 0;
        } else if (x + 25 >= width){//hits right
            rangeX = width -1 -x +25;
            startX = x-25;
        }else{
            rangeX = 50;
            startX = x - 25;
        }


        //Find points
        for(int i = startX; i < startX + rangeX; i++){
            for(int j = startY; i < startY+ rangeY; j++){
                if(points[j][i] == 1){
                    count++;
                }
            }
        }

        return count;
    }

}
